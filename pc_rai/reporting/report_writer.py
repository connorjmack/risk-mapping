"""
Report generation for RAI classification results.

Generates Markdown and JSON reports from classification statistics.
"""

import json
from datetime import datetime
from pathlib import Path
from typing import Any, Dict, Optional

from pc_rai.config import RAI_CLASS_NAMES


def write_markdown_report(
    stats: Dict,
    output_path: Path,
    input_file: str,
    config_summary: Dict,
    extent: Optional[Dict] = None,
    timing: Optional[Dict] = None,
) -> None:
    """
    Write summary report as Markdown file.

    Parameters
    ----------
    stats : dict
        Statistics dictionary from calculate_all_statistics.
    output_path : Path
        Path to output Markdown file.
    input_file : str
        Name of input file.
    config_summary : dict
        Summary of configuration parameters.
    extent : dict, optional
        Spatial extent {'x': (min, max), 'y': ..., 'z': ...}.
    timing : dict, optional
        Processing timing information.
    """
    lines = []

    # Header
    lines.append("# RAI Classification Report")
    lines.append("")
    lines.append(f"**Generated**: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    lines.append("")

    # Input section
    lines.append("## Input")
    lines.append("")
    lines.append(f"- **File**: `{input_file}`")
    lines.append(f"- **Points**: {stats['n_points']:,}")
    if extent:
        lines.append(
            f"- **Extent X**: [{extent['x'][0]:.2f}, {extent['x'][1]:.2f}]"
        )
        lines.append(
            f"- **Extent Y**: [{extent['y'][0]:.2f}, {extent['y'][1]:.2f}]"
        )
        lines.append(
            f"- **Extent Z**: [{extent['z'][0]:.2f}, {extent['z'][1]:.2f}]"
        )
    lines.append("")

    # Configuration section
    lines.append("## Configuration")
    lines.append("")
    for key, value in config_summary.items():
        lines.append(f"- **{key}**: {value}")
    lines.append("")

    # Feature statistics
    lines.append("## Feature Statistics")
    lines.append("")
    lines.append("| Feature | Mean | Std Dev | Min | Max |")
    lines.append("|---------|------|---------|-----|-----|")

    for name, feat_stats in stats["features"].items():
        if feat_stats["mean"] is not None:
            lines.append(
                f"| {name} | {feat_stats['mean']:.2f} | {feat_stats['std']:.2f} | "
                f"{feat_stats['min']:.2f} | {feat_stats['max']:.2f} |"
            )
        else:
            lines.append(f"| {name} | N/A | N/A | N/A | N/A |")
    lines.append("")

    # Classification results - Radius
    if stats["classification_radius"]:
        lines.append("## Classification Results (Radius Method)")
        lines.append("")
        _add_classification_table(lines, stats["classification_radius"])

    # Classification results - k-NN
    if stats["classification_knn"]:
        lines.append("## Classification Results (k-NN Method)")
        lines.append("")
        _add_classification_table(lines, stats["classification_knn"])

    # Method agreement
    if stats["method_agreement"]:
        lines.append("## Method Agreement")
        lines.append("")
        agreement = stats["method_agreement"]
        lines.append(
            f"- **Agreement**: {agreement['agreement_pct']:.1f}% "
            f"({agreement['agreement_count']:,} points)"
        )
        lines.append(f"- **Cohen's Kappa**: {agreement['cohens_kappa']:.3f}")
        lines.append("")

        # Kappa interpretation
        kappa = agreement["cohens_kappa"]
        if kappa < 0:
            interpretation = "Less than chance agreement"
        elif kappa < 0.20:
            interpretation = "Slight agreement"
        elif kappa < 0.40:
            interpretation = "Fair agreement"
        elif kappa < 0.60:
            interpretation = "Moderate agreement"
        elif kappa < 0.80:
            interpretation = "Substantial agreement"
        else:
            interpretation = "Almost perfect agreement"
        lines.append(f"*Kappa interpretation: {interpretation}*")
        lines.append("")

    # Timing information
    if timing:
        lines.append("## Processing Time")
        lines.append("")
        total = 0
        for stage, seconds in timing.items():
            if stage != "total":
                lines.append(f"- **{stage}**: {seconds:.2f}s")
                total += seconds
        if "total" in timing:
            lines.append(f"- **Total**: {timing['total']:.2f}s")
        else:
            lines.append(f"- **Total**: {total:.2f}s")
        lines.append("")

    # Footer
    lines.append("---")
    lines.append("")
    lines.append("*Report generated by PC-RAI*")

    # Write file
    output_path = Path(output_path)
    output_path.parent.mkdir(parents=True, exist_ok=True)
    with open(output_path, "w") as f:
        f.write("\n".join(lines))


def _add_classification_table(lines: list, class_stats: Dict) -> None:
    """Add classification statistics table to markdown lines."""
    lines.append("| Class | Count | Percentage |")
    lines.append("|-------|------:|----------:|")

    for class_code in range(8):
        cls = class_stats["by_class"][class_code]
        name = f"{cls['name']} ({cls['abbrev']})"
        lines.append(f"| {name} | {cls['count']:,} | {cls['percent']:.1f}% |")

    lines.append("")


def write_json_report(
    stats: Dict,
    output_path: Path,
    input_file: str,
    config_summary: Dict,
    extent: Optional[Dict] = None,
    timing: Optional[Dict] = None,
) -> None:
    """
    Write summary report as JSON file.

    Parameters
    ----------
    stats : dict
        Statistics dictionary from calculate_all_statistics.
    output_path : Path
        Path to output JSON file.
    input_file : str
        Name of input file.
    config_summary : dict
        Summary of configuration parameters.
    extent : dict, optional
        Spatial extent.
    timing : dict, optional
        Processing timing information.
    """
    report = {
        "metadata": {
            "generated": datetime.now().isoformat(),
            "generator": "PC-RAI",
            "version": "0.1.0",
        },
        "input": {
            "file": input_file,
            "n_points": stats["n_points"],
            "extent": extent,
        },
        "config": config_summary,
        "statistics": {
            "features": stats["features"],
            "classification_radius": stats["classification_radius"],
            "classification_knn": stats["classification_knn"],
            "method_agreement": _serialize_agreement(stats.get("method_agreement")),
        },
        "timing": timing,
    }

    # Write file
    output_path = Path(output_path)
    output_path.parent.mkdir(parents=True, exist_ok=True)
    with open(output_path, "w") as f:
        json.dump(report, f, indent=2, default=_json_serializer)


def _serialize_agreement(agreement: Optional[Dict]) -> Optional[Dict]:
    """Serialize method agreement for JSON output."""
    if agreement is None:
        return None

    # Convert per_class_agreement keys to strings
    result = agreement.copy()
    result["per_class_agreement"] = {
        str(k): v for k, v in agreement["per_class_agreement"].items()
    }
    return result


def _json_serializer(obj: Any) -> Any:
    """Custom JSON serializer for numpy types."""
    import numpy as np

    if isinstance(obj, np.integer):
        return int(obj)
    elif isinstance(obj, np.floating):
        return float(obj)
    elif isinstance(obj, np.ndarray):
        return obj.tolist()
    raise TypeError(f"Object of type {type(obj)} is not JSON serializable")


def generate_config_summary(config: Any) -> Dict:
    """
    Generate configuration summary for reports.

    Parameters
    ----------
    config : RAIConfig
        Configuration object.

    Returns
    -------
    dict
        Summary dictionary.
    """
    return {
        "methods": config.methods,
        "radius_small": f"{config.radius_small}m",
        "radius_large": f"{config.radius_large}m",
        "k_small": config.k_small,
        "k_large": config.k_large,
        "min_neighbors": config.min_neighbors,
        "thresh_talus_slope": f"{config.thresh_talus_slope}°",
        "thresh_overhang": f"{config.thresh_overhang}°",
        "thresh_cantilever": f"{config.thresh_cantilever}°",
    }
